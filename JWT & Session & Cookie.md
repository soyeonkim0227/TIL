# 1. 쿠키(Cookie)

---

- 쿠키는 클라이언트의 로컬 컴퓨터에 저장되는 작은 데이터 파일임. 쿠키는 클라이언트의 브라우저에 저장되며, 서버 측에서 생성되어 클라이언트에게 전송됨. 클라이언트가 서버에 다시 요청을 보낼 때마다, 브라우저는 쿠키를 서버에 전송함. 쿠키는 다양한 용도로 사용될 수 있으며, 대표적으로 로그인 정보나 사용자 선호도 등을 저장하는 데 사용됨.

## 1-1. 정의

- <Key, value> 형태의 문자열로 브라우저에 저장되어 사용자를 인식하거나 일부 데이터를 저장하는 역할을 수행함.
- 서버가 클라이언트에 정보를 전달할 때 저장하고자 하는 정보를 응답 헤더(Cookie)에 저장하여 전달함.

## 1-2. 등장 배경 - 왜?

- 서버에 요청할 때마다 사용자가 ID, PW를 통해 로그인을 해야하는 불편함이 있었기 때문임.
- Cookie는 사용자가 한 번 로그인을 하면, 쿠키를 생성하여 저장하고 이후 요청은 로그인 없이 진행할 수 있는 편의성을 제공해줌.

## 1-3. 문제점

- Cookie가 노출되었을 때 ID, PW와 같은 중요 정보들이 쉽게 노출됨.
- 웹 브라우저마다 Cookie에 대한 지원 형태가 다르기 때문에 브라우저 간 공유가 불가능함.
- Cookie의 사이즈는 4KB로 제한되어 많은 양의 데이터를 담을 수 없음.

# 2. 세션(Session)

---

- 세션은 서버에 저장되는 정보임. 세션은 클라이언트가 서버에 접속할 때 서버 측에서 생성되어 세션 ID라는 고유한 값을 부여함. 이후 클라이언트가 서버에 요청을 보낼 때마다, 해당 세션 ID를 서버에 전송하게 됨. 서버는 이를 기반으로 클라이언트에 대한 정보를 관리하며, 이를 통해 로그인 상태 유지 등에 사용됨.

# 2. Cookie + Session

---

## 2-1. 등장 배경 - 왜?

- Cookie의 문제점을 해결하기 위해 나온 개념임.

Cookie에 ID, PW와 같은 중요 정보들을 담는게 아니라, 중요 정보가 아닌 인증을 위한 별개의 정보를 세션 저장소에 저장하고, 클라이언트는 이 정보를 쿠키에 대신 담아서 요청하고 서버는 세션 저장소에 있는 정보랑 일치하는지 확인하는 방식임.

## 2-2. 동작 과정

1. 클라이언트가 ID/PW로 서버에 로그인 요청
2. ID/PW로 인증 후 사용자를 식별할 특정 유니크한 세션 ID를 만들어 마치 자물쇠처럼 서버의 세션 저장소에 저장
3. 세션 ID를 특정한 형태(Cookie or json)로 클라이언트에 다시 반환
4. 이후 사용자 인증이 필요한 정보를 요청할 때마다 이 세션 ID를 쿠키에 담아 서버에 함께 전달
5. 인증이 필요한 api일 때, 서버는 세션 ID가 세션 저장소에 있는지 확인
6. 있다면 인증 완료 후 api 처리, 없다면 401 에러를 반환

## 2-3. 쿠키와 세션의 차이점

- **쿠키**는 클라이언트에 저장되고, **세션**은 서버에 저장됨.
- **쿠키**는 브라우저를 종료해도 유지되지만, **세션**은 브라우저를 종료하면 삭제됨.
- **쿠키**는 보안에 취약할 수 있으며, 클라이언트에서 조작이 가능하지만,
- **세션**은 보안에 강하고, 클라이언트에서 조작이 불가능함.
- 따라서 보안이 중요한 정보에 대해서는 세션을 사용하는 것이 좋음.

## 2-4. 문제점

- 세션 ID, Cookie 등이 탈취된다면 세션 저장소를 전부 지워 해결 가능하지만, 탈취 당하지 않은 정상적인 사용자도 모두 재인증을 해야하는 상황이 발생함.
- 무엇보다 http의 가장 큰 특성 중 하나인 `stateless`를 위배한다는 것임. `stateless`라면 서버는 클라이언트의 상태를 저장하지 않아야 하지만 세션 저장소라는 곳에서 클라이언트의 상태를 저장하게 되므로 `stateful`하게 됨.
- 이게 뭐가 문제야?라고 생각할 수 있지만 만약 서버를 스케일 아웃해야 한다면? 1번 서버에 로그인한 사용자가 다른 2번 서버로 요청을 보내게 된다면, 2번 서버에는 로그인 상태가 남아있지 않기 때문에 다시 로그인해야 하는 상황이 발생함.

## 2-5. 문제점 해결

### 세션 클러스터링

- 세션 클러스터링으로 서버 간 로그인 정보가 담긴 세션을 공유하는 방법이 있지만 실제 서비스와 관련없는 인프라적인 작업으로 서버 리소스를 많이 쓰게 되는 단점이 있음
- 전체적인 서버 규모가 크지 않다면 나쁘지 않은 방법이지만, MSA로 잘게 쪼개져 수십 수백 개의 서버로 이루어진다면 단점이 극명하게 드러날 것임.

### 스티키 세션

- 스케일 아웃 시 여러 서버에 세션 정보를 복사할 필요 없도록 특정 세션을 처음 처리한 서버에게 이후 같은 세션의 요청을 같은 서버가 처리하도록 하는 방식임.
- A사용자가 맨처음에 A서버에게 요청했다면 이후 요청은 모두 A서버가 처리하는 방식임.
- 문제점은 각 서버가 균일하게 요청을 처리할 수 없다는 점, 특정 서버에게 요청이 몰릴 수도 있다는 문제점이 있음. 즉, 로드가 균일하게 밸런싱되지 않음.
- 무엇보다 클라이언트의 상태를 어디선가 들고있어야 한다는 문제점을 해결하지 못했음.

> 이러한 문제점들을 해결하기 위해 나온 개념이 JWT
> 

# 3. JWT

---

## 3-1. JWT 정의

- JSON Web Token(JWT)은 웹표준(RFC7519)으로서 두 개체에서 JSON 객체를 사용하여 가볍고 자가 수용적인 (self-contained) 방식으로 정보를 안전성 있게 전달함.
    - 자가 수용적이라는 의미는 JWT 안에 인증에 필요한 모든 정보를 자체적으로 지니고 있다는 의미임.

## 3-2. 인증 과정

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/0f0900ea-e01c-42e2-975e-14285d451b24/Untitled.png)

## 3-3. JWT 구조

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/6cd05a10-74c4-4e0d-976c-f2bc4b04f3b6/Untitled.png)

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/e7953e0d-974d-4ea9-8d24-9d31f5ed9a3f/Untitled.png)

- 각 부분을 구분하기 위한 `.`구분자가 들어감.

### 헤더(Header)

- 헤더는 두 가지 정보를 가짐.
    1. typ - 토큰의 타입(JWT)
    2. alg - 해싱 알고리즘
        1. Signature를 해싱하기 위한 알고리즘 지정

### 내용(Payload)

- 토큰에 담을 정보들이 존재하고 여기에 담는 정보의 한 조각을 `클레임(claim)`이라고 함.
- 클레임은 키 값 형태로 존재
    - 클레임의 종류는 등록된(registered) 클레임, 공개(public) 클레임, 비공개 클레임 등이 있음.
- 페이로드 ex)
    
    ```python
    {
            "iss": "jh.com", // 등록된 클레임
            "exp": "1485270000000", // 등록된 클레임
            "<https://xxx.com/jwt_claims/is_admin>": true, // 공개 클레임
            "userId": "11028373727102", // 비공개 클레임
            "username": "jh" // 비공개 클레임
        }
    ```
    

### 서명(Signature)

- **Signature**란 토큰을 인코딩하거나 유효성 검증을 할 때 사용하는 고유한 암호화 코드임.
- 서명 생성 과정
    1. 헤더와 페이로드 값을 각각 `BASE64`로 인코딩
    2. 1번에서 인코딩한 값을 비밀 키로 이용해 헤더에서 정의한 알고리즘으로 해싱
    3. 2번에서 해싱한 값을 다시 `BASE64`로 인코딩

## 3-4. 등장 배경 - 왜?

- 인증에 필요한 정보가 토큰에 들어있어서 별도의 저장소가 필요 없음.
    - 하지만 보안성을 높이기위해 `Refresh Token`을 사용하는 경우 별도의 저장소에 저장하면서 사용하는 경우에는 해당하지 않음.
- Cookie와 Session 사용 시 문제점이었던 stateful 특성을 JWT 사용 시 stateless하게 가져갈 수 있음. 즉, 서버는 클라이언트의 상태를 가질 필요가 없음.
- 다양한 언어에서 지원함.
- HTTP 헤더에 넣어서 쉽게 전달 가능함.
- MSA 환경에서 유용함.

## 3-5. 단점

- 거의 모든 요청에 토큰이 포함되므로 트래픽 크기에 영향을 미칠 수 있음.
- 토큰에 정보가 많아져 토큰의 크기가 커지면 네트워크에 부하를 줄 수 있음.
- 페이로드는 암호화된게 아니라 `BASE64`로 인코딩 된 것이므로 중간에 토큰을 탈취하면 페이로드의 데이터를 모두 볼 수 있음.
    - 따라서 페이로드에는 중요 정보를 담아서는 안 됨.

# 4. JWT 암호화 방식

---

JWT를 생성 시 JWT 헤더와 페이로드 정보를 인코딩하고, 둘을 합친 문자열을 비밀 키로 서명함. 이때 대칭키, 비대칭키 방식을 사용할 수 있음.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/ba258293-c4f5-472a-bbc6-3d66762a3ff6/Untitled.png)

## 4-1. 대칭키 암호화

- 암호화 복호화 키가 같으면 대칭키 암호화 방식이라고 함.
같은 키를 사용해 암호화, 복호화를 수행하기 때문에 속도가 빠름.
- 대표적으로 HMAC 암호화 알고리즘이 있음.
    - HS256, HS384, HS512 … 가 이에 해당하고 뒤 숫자는 secret Key의 최소 바이트 크기를 의미함.
    - 기본적으로 단방향 암호화 알고리즘인 SHA-256과 함께 쓰임.
- 값에 SHA-256를 적용해서 해싱 후 private key(== secret key, 대칭키 역할)로 암호화 함.
- private key를 알고있는 서버만 Signature 유효성 검증이 가능함. 즉, JWT를 복호화 할 수 있음.

## 4-2. 비대칭키 암호화

- 암호화 복호화 키가 다르면 비대칭키 암호화 방식이라고 함. 다른 키를 사용해 암호화, 복호화를 수행하기 때문에 속도가 느리지만, 그만큼 안전함.
- 대표적으로 RSA 암호화 알고리즘이 있음.
    - 마찬가지로 SHA-256 단방향 암호화 알고리즘과 함께 쓰임.
- 값에 SHA-256를 적용해서 해싱 후 private key(비밀키)로 암호화 함.
- 그리고 public key(공개키)는 공개적으로 제공함. 어떠한 서버든 이 public key를 통해 JWT를 복호화 할 수 있음.

## 4-3. 그래서 어떤 차이점이? (feat. 인증서버)

- 대칭키 암호화 방식같은 경우는 private key를 모르는 서버는 JWT의 유효성을 검증할 수 없음.
- 반대로 비대칭키 복호화는 private key를 몰라도 public key를 통해 복호화할 수 있기 때문에 JWT의 유효성을 검증할 수 있음.

> 둘 차이의 핵심은 별도의 인증 서버를 구축할 때 편의성 차이에 있음. 인증 서버의 역할은 모든 애플리케이션 서버에서 JWT를 발급하는게 아니라, 별도의 인증 서버가 JWT를 발급해주는 역할을 수행함. 당연히 JWT 검증은 각 애플리케이션 서버에서 수행함. 또는 API GW(GateWay)가 존재한다면 API GW에서 수행하면 됨.
> 

### 대칭키 암호화 방식에서의 인증 서버 구축하기

1. 인증 서버가 클라이언트에게 JWT를 발급
2. 클라이언트는 JWT와 함께 애플리케이션 서버에 요청
3. 애플리케이션 서버는 인증 서버의 private key를 모르므로 JWT를 검증할 수 없음.

각 애플리케이션 서버에 인증 서버의 private key를 넣어놓으면 되긴함. 하지만 MSA 환경에서 수많은 애플리케이션 서버가 존재하는데, scale-out 할 때마다 매번 private key를 넣어줘야 함.

### 비대칭키 암호화 방식에서의 인증 서버 구축하기

1. 인증 서버가 클라이언트에게 JWT를 발급
2. 클라이언트는 JWT와 함께 애플리케이션 서버에 요청
3. 애플리케이션 서버는 인증 서버의 public key를 통해 JWT를 검증할 수 있음.

각 애플리케이션 서버에 일일히 key를 넣어줄 필요가 없음. public key가 공개되어 있으므로.

### API Gateway가 존재한다면?

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/785e14bf-0d4e-43a5-a683-8c1461b7a90d/Untitled.png)

- 비대칭키 암호화 방식을 사용하면 매번 각 서버에서 필터나 인터셉터를 통해 JWT에 대한 검증을 수행할 것임. 하지만 API Gateway가 존재하면 API GW에서만 검증하면 됨. API GW에서 public key를 통해 검증해도 되지만, 대칭키 방식을 사용해도 API GW에만 private key를 넣어주면 되므로 대칭키 방식의 문제점도 딱히 드러나지 않음.

> 간단히 개인적인 결론을 내려보면 API GW가 없다면 비대칭키 암호화 방식을 사용하는게 좋고 API GW가 존재한다면 어떤 방식을 쓰든 상관없을 것 같다는 생각이 듦.
> 

# 5. Refresh Token

---

## 5-1. 등장 배경 - 왜?

- 보안에 100%는 없음. 따라서 토큰이 노출되어 탈취당할 경우를 대비해야 하는데 이런 경우를 대비해 사용하는게 `Refresh Token`임. `Access Token`만으로 공격자가 요청하는 것인지 정상적인 클라이언트가 요청하는 것인지 알 수 없기 때문임.
- `Access Token`은 언제든지 탈취될 수 있다고 가정하기 때문에 `Access Token`에는 중요 정보를 담으면 안됨.
- 따라서 `Access Token`은 유효기간을 짧게 설정하고 `Refresh Token`의 유효기간은 길게 설정함. 물론 `Access Token`의 유효기간 동안에는 공격에 노출되어 있지만 피해를 최소화 하기 위한 방법임.

## 5-2. 동작 방식

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/5a423f7d-fa42-4ea8-8d28-87309f0c2b19/Untitled.png)

- `Access Token`이 탈취됐을 때 대비를 위해 `Refresh Token`개념을 도입함. 그런데 `Access Token`과 `Refresh Token` 모두 클라이언트에 저장되면 같이 탈취되는거 아닌가? 라는 생각이 듦.
- 그래서 `Access Token`을 로컬 스토리지 또는 세션 스토리지에 저장하고, `Refresh Token`은 쿠키에 저장하고 보안 옵션들(HTTP Only, Secure Cookies)을 활성화 함.
- 물론 `Refresh Token`은 서버에도 저장돼있어야 함.

### HTTP Only Cookies

- 클라이언트에서 자바스크립트로 쿠키를 조회할 수 있는데 해당 옵션을 활성화 하면 브라우저에서 쿠키에 접근할 수 없으므로 XSS와 같은 공격으로부터 안전함.

### Secure Cookies

- http 프로토콜은 언제든지 패킷을 중간에 가로챌 수 있음. 그래서 보안 개념을 추가한 https 프로토콜을 사용하여 데이터를 암호화해 통신함.
- 문제는 https로 전송되어야 할 정보가 휴먼에러로 인해 http로 전송될 때가 있음.
- 그래서 https 프로토콜이 아닌 경우에는 쿠키를 전송하지 않도록 설정하는 옵션임.

> HTTP Only Cookies와 Secure Cookies에 대한 자세한 내용은 링크를 참고: [https://nsinc.tistory.com/121](https://nsinc.tistory.com/121)
> 

## 5-3. Refresh Token만 탈취되면?

- 공격자는 탈취한 `Refresh Token`으로 계속 `Access Token`을 생성해서 정상적인 사용자처럼 서버에 계속 요청할 수 있음.
- 이를 대비해서 서버에서 추가 검증 로직으로 방어해야 함.
    - DB에 사용자와 `Access Token`, `Refresh Token`들을 매핑하여 저장함.
    - 정상적인 유저의 `Access Token`이 만료된 경우
        - `Access Token`과 `Refresh Token`을 서버로 보내서 새 `Access Token`을 요청함. → 서버에서는 DB에 저장된 `Access Token`, `Refresh Token`쌍과 클라이언트에서 보낸 토큰 쌍들을 비교함. → 일치하면 새 `Access Token`을 발급해줌.
    - 공격자가 `Refresh Token`을 탈취한 경우
        - 공격자가 탈취한 `Refresh Token`으로 새 `Access Token` 생성 요청 → `Access Token`이 없이 요청하면 공격으로 간주 → 서버에서 `Access Token`, `Refresh Token` 폐기

## 5-4. Refresh Token, Access Token 모두 탈취되면?

- 만약 `Access Token`, `Refresh Token`이 둘 다 탈취되면?? 공격자는 정상적인 유저처럼 요청하고, 새 `Access Token` 발급받고 .. 모두 가능함.
- 즉 방법이 없음. 보안에 100%는 존재하지 않음.

# 6. JWT와 Session Cookie 비교

---

## 6-1. 누가 더 안전한가?

- 사실 누가 더 안전한가라는 질문은 올바르지 못함. Session, cookie, JWT든 뭐든 모두 HTTP 프로토콜 위에서 동작하는 text일 뿐임. 네트워크 레이어에 공격자가 접근하여 탈취할 수만 있다면 모두 노출될 수 밖에 없음.
- 즉, 누가 더 안전하고 누가 더 취약하고는 논할 수 없다는 이야기임.

## 6-2. 그럼 어떤 차이점이?

- stateful과 stateless 측면에서 차이점이 존재함. 이는 토큰이 탈취됐을 때 서버에서 능동적으로 이에 대응하여 토큰을 폐기 처리할 수 있냐 없느냐에 직결됨.
- JWT의 등장 배경을 살펴보면 보안이 뛰어나서가 아니라 마이크로 서비스 아키텍처(MSA)가 도입되면서 주목받기 시작했음.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/296e78f2-7278-4fe9-8b82-74c35f4a15e3/Untitled.png)

- 위 사진처럼 수천 수만가지의 서버 to 서버 통신이 이루어지는 아키텍처에서 중앙화된 사용자 식별 저장소를 통해 각 API 요청을 인증처리 해야한다면.. 인증 서버만 수백대가 필요할 것임. 그렇다고 아무리 내부 서버 끼리의 통신이라고 인증을 제외할 순 없으니 JWT를 통해 인증을 진행하는 것임.
- 추가로 앱과 웹을 모두 서비스하는 서버인 경우 웹에서는 Session을 이용하고 앱에서는 토큰을 이용하는 방식으로 별개의 인증방식을 가져가는게 아니라, 두 환경 모두 토큰을 기반으로 인증하여 환경에 구애받지 않고 동일한 API를 이용할 수 있음.

# 7. 마무리

---

## 쿠키

- 적은 용량과 보안 문제점 존재

## 쿠키 + 세션

- 쿠키의 문제점을 해결
- 문제점
    - 상태를 저장해야 하므로, 즉 세션 정보를 저장하기위한 추가 저장소가 필요하고 이는 `http stateless` 특성을 위반함.
        - 즉 로그인할 때마다 세션 스토리지(추가 저장소)에 접근해서 확인해야 함.
    - 스케일 아웃 시 여러 서버에 세션 정보를 복사해줘야 하는 작업이 필요함.
    - 이를 해결하기 위한 개념인 스티키 세션, 세션 클러스터링이 등장했지만 여전히 `stateful`하다는 문제점을 해결하지 못했음.

## JWT

- 클라이언트의 상태를 들고있을 필요 없이 토큰만으로 인증처리가 가능함. 즉, `stateless`함.
- MSA에서 중앙화 된 인증방식에 비해 유리함.
- 그런데 보안 문제로 Refresh Token을 도입하면 결국 이를 저장하기 위한 별도의 저장소가 필요한건 마찬가지임. 즉, stateless하지 않음
- 하지만 세션은 로그인할 때마다 저장소에 접근하지만 JWT는 토큰이 만료되었을 때만 저장소에 접근하기 때문에 접근하는 횟수 자체는 훨씬 적음.
- access token을 사용하는 기간동안은 stateless하지만, 만료되었을 때는 stateless가 깨지게 됨.
- MSA 환경에서 유용함.
